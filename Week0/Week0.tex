\documentclass[12pt]{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx,mathabx}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{placeins}
\usepackage{lipsum}
\usepackage[shortlabels]{enumitem}
\begin{document}
\title{TCSS 343 - Week 0}
\author{Jake McKenzie}
\maketitle
\noindent\centerline{\textbf{Introduction to Algorithmic Thinking and Recursion}}\\\\\\\\\\\\\\\\
\begin{center}
    ``So plant your own gardens and decorate your own soul, instead of waiting for someone to bring you flowers." $\sim$ Jorge Luis Borges
\end{center}
\begin{center}
    ``Beware of bugs in the above code; \\I have only proved it correct, not tried it." $\sim$ Donald Knuth
\end{center}
\begin{center}
Listen to the \textbf{MUSTN'TS}, child,\\
      Listen to the \textbf{DON'TS}\\
      Listen to the \textbf{SHOULDN'TS}\\
The \textbf{IMPOSSIBLES}, the \textbf{WONT'S}\\
      Listen to the \textbf{NEVER HAVES}\\
Then listen close to me-\\
      Anything can happen, child,\\
      \textbf{ANYTHING} can be\\ 
      $\dots$\\
      Shel Silverstein 
\end{center}
    \newpage
\noindent 0. Emily loves figuring out all the ways to arrange dominos. Help her find all the ways to arrange dominos in that are $2 \times 1$ in a $2 \times 1$,$2 \times 2$,$2 \times 3$ and $2 \times 4$ grid!\\\\\\\\\\\\\\\\\\\\\\\\
\noindent 1. Now that you've helped Emily find how many ways to arrange the dominos in problem 0 she gets really philosophical. She starts pondering the nature of zero and wants you to help her find how many ways to arrange a $2 \times 1$ domino in a $2 \times 0$ grid. (You don't have to be too smart: Just find some justification from problem 0)\\\\\\\\\\\\\\\\
\noindent 2. We've had a lot of fun arranging dominos but now Emily wants a recursive formula for the ways to arrange $2 \times 1$ dominos. The key to finding recursive definitions is to find the answer to larger problems by finding the answer to smaller problems.\\\\
$D_n = $\# of tilings of a $2 \times n =$
\newpage
\noindent 3. The average number of key comparisons done in a successful sequential search in a list of length $n$ is?
\begin{enumerate}
    \item[a)]$\log{n}$
    \item[b)]$\frac{n-1}{2}$
    \item[c)]$\frac{n}{2}$
    \item[d)]$\frac{n+1}{2}$
\end{enumerate}
4. What is the invariant of a B-Tree?\\\\\\\\\\\\
\centerline{\includegraphics[scale=0.9]{prim.jpg}}
5. What is the worst case runtime of Prim's algorithm minimum spanning tree for a weighted undirected graph?
\begin{enumerate}
    \item[a)]$|E|\log{|E|}$
    \item[b)]$|E|\log{|V|}$
    \item[c)]$|E|$
    \item[d)]$|V|$
    \item[e)]$|E^2|$
    \item[f)]$|V^2|$
\end{enumerate}
\newpage
\noindent 6. Calculate the following anti-derivatives from $1$ to $n$ with respect to $x$. (Because I am a nice person. Remember that $\log_2{x}=\frac{\ln{x}}{\ln{2}}$). I have run into all of these integrals when computing runtimes of algorithms, I know you didn't expect this to be so much math but please, please don't hate me. I added these because I care.
\begin{enumerate}
    \item[a)]$6+7x+2x^2$
    \item[b)]$2^n$
    \item[c)]$\log_{2}{x}$
    \item[d)]$\frac{1}{x^2}$
    \item[e)]$\frac{1}{x}$
    \item[f)]$\frac{\log_{2}{x}}{x}$
\end{enumerate}
\newpage
\noindent 7. Calculate the second derivative of the product $f(n) \cdot g(n)$ with respect to n. Expand and collect like terms. Why is this useful? How could we use this to make our lives easier in the future?\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\noindent 8. Use your result from 7 to calculate the second derivative of the product $f(n) = n + 1$ and $e^{2n}$.\\\\\\\\\\\\\\\\\\\\\\\\
\noindent 9. How many operations did you save by using the general result you obtained vs not using it?
\newpage
\centerline{\includegraphics[scale = 0.25]{boxing.jpg}}
\noindent A. Let's say we have a group of champions in a room and we want to pit them against one another until there is one and only one winner. This is analogous to finding the max value in an array of integers. Write a simple recursive algorithm which returns back the max.\\\\\\\\\\\\\\\\\\\\\\\\\\
\noindent B. Attempt to prove that this algorithm is correct by contradiction. 
\newpage
\noindent C. Benin is a fisherman who is simply good at fishing. One day, he finds a nice place to go fishing with two ponds. 
Moving from the $i-th$ fish-pond (the one he starts at) to the $j-th$ fishpond would cost $|i - j|$ units of time. 
Initially Benin can get $F_i$ fish in the $i-th$ fishpond. 
In the next turn at the same fishpond, the amount of fish he can get is decreased by $D_i$. 
Notice that Benin will not get negative amount of fish.
Each turn of fishing takes Benin 1 unit of time if Benin is at that pond and $|i - j|$ units of time to switch.
\\\\
For example, if $F_1 = 10$, $F_2 = 5$, $D_1 = 2$, $D_2 = 3$ and Benin can fish for up to eight units of time, then he will get $10 + 8 + 6 + 5 + 4 = 33$.
Washington Department of Fish and Wildlife (WDFW) requires that Benin switch to the adjacent pond when it has more fish and he cannot fish for "negative" fish.
Write a recursive algorithm to see how many fish Benin can fish for!
\newpage
\noindent D. On the last page we had lots of fun but let's get a little more practical. Programmers, no matter what language they use, typically think of their data in trees. Whether their is a collection of JSON objects, Python dicts or Ruby hashes, they're usually a tree. Javascript developers may even take their JSON objects and render them to the DOM, which also happens to be a tree. Trees, trees and more trees. Write a function using recursion that returns true if the tree is symmetric. I encourage you to write as many helper functions as you want.\\
\centerline{\includegraphics[scale = 0.5]{binarytree.jpg}}
\centerline{(Various binary trees courtesy of Wolfram Mathworld)}
\newpage
\noindent E. Now that you've done this attempt to write a function which will invert a binary tree using recursion.\\
\centerline{\includegraphics[scale = 0.4]{invertbtree.png}}
\newpage
\noindent F. I'm sorry for making you go through this packet. To be honest I've never been a fan of recursion myself but it is a powerful tool in solving problems. Now that you've completed the previous part of the packet. Reattempt problem 7 by now writing an iterative way of inverting a binary tree.
\centerline{\includegraphics[scale = 0.4]{invertbtree.png}}
\end{document}